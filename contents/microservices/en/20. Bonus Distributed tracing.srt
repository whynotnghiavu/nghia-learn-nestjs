1
00:00:01,050 --> 00:00:06,100
Distributed tracing is a technique used in
the context of microservices architecture

2
00:00:06,150 --> 00:00:08,610
who monitor and analyze
the flow of requests

3
00:00:08,820 --> 00:00:12,670
as they traverse multiple
services in a distributed system.

4
00:00:13,410 --> 00:00:18,150
Understanding the
interactions between services

5
00:00:18,150 --> 00:00:18,600
is crucial for diagnosing
performance issues

6
00:00:18,900 --> 00:00:20,430
understanding system behavior

7
00:00:20,790 --> 00:00:23,440
and optimizing overall
system performance.

8
00:00:23,730 --> 00:00:26,290
When a single user
request this processed.

9
00:00:26,370 --> 00:00:31,110
It often involves
multiple interconnected

10
00:00:31,110 --> 00:00:32,320
microservices working
together to fulfill that request.

11
00:00:32,940 --> 00:00:36,840
Distributed tracing helps track the
journey of a request through the services

12
00:00:36,900 --> 00:00:41,070
allowing developers and operations
teams to gain valuable insights into

13
00:00:41,280 --> 00:00:43,150
how the services collaborate

14
00:00:43,290 --> 00:00:46,120
and identify potential
bottlenecks or errors.

15
00:00:46,590 --> 00:00:51,300
This is particularly useful in complex
systems were a single request can trigger a

16
00:00:51,300 --> 00:00:54,430
cascade of events that
spanned multiple services.

17
00:00:55,350 --> 00:00:59,370
To implement distributed tracing in
our system we usually assigned a unique

18
00:00:59,370 --> 00:01:03,570
identifier to each
request and propagated

19
00:01:03,570 --> 00:01:04,570
through the system as
the request is processed.

20
00:01:05,040 --> 00:01:05,850
As identifier

21
00:01:06,060 --> 00:01:07,960
is called a trace ID.

22
00:01:08,940 --> 00:01:12,630
Since trace ID is going to be passed
along with the request it can be used to

23
00:01:12,630 --> 00:01:16,980
correlate all the logs
and events generated by

24
00:01:17,040 --> 00:01:18,310
the services involved in
processing that request.

25
00:01:19,260 --> 00:01:23,940
We can then use tracing
systems to visualize the

26
00:01:24,000 --> 00:01:25,500
entire trace understanding
the latency between services

27
00:01:25,740 --> 00:01:29,723
identify bottlenecks detect
errors and optimize performance.

28
00:01:30,390 --> 00:01:31,200
In this lesson

29
00:01:31,320 --> 00:01:35,760
will focus on how to automatically generate
trace ids and propagate them through the

30
00:01:35,760 --> 00:01:38,080
system in our
nest js applications.

31
00:01:38,340 --> 00:01:38,880
To begin.

32
00:01:39,300 --> 00:01:43,749
Let's create a new library called
tracing using the nest see ally.

33
00:01:48,300 --> 00:01:51,090
Let's open the newly
generated tracing service file

34
00:01:51,390 --> 00:01:53,230
and add the following code.

35
00:01:55,230 --> 00:02:00,520
This method simply generates a random
you you ID that will use as our trace ID.

36
00:02:00,690 --> 00:02:02,670
We need to a sinus ID only once.

37
00:02:03,120 --> 00:02:05,550
When the http request
hits the application

38
00:02:05,820 --> 00:02:08,201
or when a cron job is trigger.

39
00:02:08,700 --> 00:02:10,320
Once we have the trace ID

40
00:02:10,500 --> 00:02:14,640
we need to propagate it through the system
so that it can be used to court late all

41
00:02:14,640 --> 00:02:19,300
the logs in events generated by the services
involved in processing of this request.

42
00:02:19,620 --> 00:02:20,310
In this lesson

43
00:02:20,610 --> 00:02:25,240
will focus on adding tracing to are alarmed
generator events processing pipeline.

44
00:02:26,160 --> 00:02:26,550
So

45
00:02:26,670 --> 00:02:30,690
let's head over to the alarms
generator service file and

46
00:02:30,690 --> 00:02:32,580
update the generate alarm
method to generate a trace ID

47
00:02:32,850 --> 00:02:34,560
using our new tracing service.

48
00:02:35,010 --> 00:02:36,780
In the tattered to
the message headers

49
00:02:37,050 --> 00:02:39,280
under the trace ID key.

50
00:03:00,180 --> 00:03:02,460
Note that to construct
the headers object

51
00:03:02,640 --> 00:03:04,830
we use the nats headers function

52
00:03:05,010 --> 00:03:06,990
as we're using
nats in our system

53
00:03:07,290 --> 00:03:07,650
but

54
00:03:07,920 --> 00:03:10,320
if your system was using
something aside from nats

55
00:03:10,620 --> 00:03:13,600
you'd want to use the
equivalent functionality there.

56
00:03:13,950 --> 00:03:17,550
Now to make the tracing service
available any alarms generator module.

57
00:03:17,910 --> 00:03:22,270
We simply need to import the tracing
module so let's go ahead and do that now.

58
00:03:22,950 --> 00:03:24,250
Aunt perfect.

59
00:03:24,780 --> 00:03:28,718
But all this and place we cannot
switch our focus to the alarms service.

60
00:03:29,370 --> 00:03:33,300
Our goal now is to make sure that the
trace ID is propagated through the system

61
00:03:33,480 --> 00:03:36,400
when the alarm service
processes the message.

62
00:03:36,840 --> 00:03:40,860
Also let's make sure to automatically
right the trace ID to the log messages

63
00:03:41,130 --> 00:03:42,360
so let's create a new

64
00:03:42,630 --> 00:03:44,190
terrain sing lager class

65
00:03:44,490 --> 00:03:46,680
that extends the default
console lager class

66
00:03:46,950 --> 00:03:50,190
and overrides the format
context method for us.

67
00:03:50,820 --> 00:03:51,570
To achieve this.

68
00:03:52,110 --> 00:03:56,190
Let's create a new file in the tracing
library called tracing dot lager dot t s

69
00:03:56,460 --> 00:03:58,300
and add the following code.

70
00:03:59,760 --> 00:04:00,030
And

71
00:04:00,150 --> 00:04:01,960
let's breakfast class down.

72
00:04:02,010 --> 00:04:06,611
First we need to inject the request
context and enquirer objects.

73
00:04:06,930 --> 00:04:09,960
The request context object
represents the execution context

74
00:04:10,200 --> 00:04:11,640
of the incoming request.

75
00:04:12,000 --> 00:04:15,280
Which will used to
extract the trace ID from.

76
00:04:16,170 --> 00:04:20,490
Here we assume that
the logger will be used

77
00:04:20,490 --> 00:04:21,490
only by services that
use the nats transport.

78
00:04:22,350 --> 00:04:27,240
The enquirer object contains
the host object which will

79
00:04:27,240 --> 00:04:29,130
used to extract the name of
the class that using the logger.

80
00:04:29,550 --> 00:04:30,540
So for example

81
00:04:30,810 --> 00:04:32,760
if we use the logger
in the alarm service

82
00:04:33,030 --> 00:04:36,880
the enquirer object will contain
the alarms service instance.

83
00:04:38,010 --> 00:04:41,100
And likewise if we inject the
logger into the alarms controller

84
00:04:41,340 --> 00:04:45,040
the enquirer object will contain
the alarms controller instance.

85
00:04:45,270 --> 00:04:46,830
This means that
are lager provider

86
00:04:47,100 --> 00:04:48,750
will not only be request scoped

87
00:04:49,080 --> 00:04:50,760
but also transient scoped.

88
00:04:51,210 --> 00:04:54,960
Which means that a
new instance of the logger

89
00:04:54,960 --> 00:04:55,470
will be created for
each class that uses it.

90
00:04:56,100 --> 00:04:58,200
Now onto the format
contexts the method.

91
00:04:58,800 --> 00:05:03,600
Here we need to extract
the trace ID from the

92
00:05:03,630 --> 00:05:04,630
request context independent
to the log message.

93
00:05:05,280 --> 00:05:09,390
Finally we need to register the tracing
lager as a provider in the tracing module

94
00:05:09,660 --> 00:05:10,080
so

95
00:05:10,350 --> 00:05:13,930
let's open up the tracing module
t s file and add the following code.

96
00:05:18,360 --> 00:05:19,360
Excellent.

97
00:05:20,310 --> 00:05:24,780
With this and place let's navigate to our
alarm service and update the alarms module

98
00:05:24,780 --> 00:05:27,490
file to import the
tracing module.

99
00:05:33,960 --> 00:05:34,440
Next

100
00:05:34,740 --> 00:05:39,090
let's head of to the
alarms service controller

101
00:05:39,090 --> 00:05:39,570
file and updated to
inject the tracing lager.

102
00:05:39,930 --> 00:05:42,880
Replacing the existing
local lager instance.

103
00:05:47,490 --> 00:05:51,360
Let's save our changes
head over to the terminal

104
00:05:51,360 --> 00:05:52,810
and start everything up
with docker compose up.

105
00:06:02,970 --> 00:06:04,620
Once the application
is up and running.

106
00:06:05,010 --> 00:06:05,910
Let's wait a little bit

107
00:06:06,030 --> 00:06:07,630
and observe the locks.

108
00:06:17,610 --> 00:06:18,450
As we can see

109
00:06:18,750 --> 00:06:23,380
all logs in the alarm service
controller contain a trace idina great.

110
00:06:23,640 --> 00:06:24,180
However

111
00:06:24,510 --> 00:06:29,820
our trace ID is not yet propagated to the
alarms classifier and notification services

112
00:06:29,942 --> 00:06:31,960
let's go ahead and fixed us now.

113
00:06:32,310 --> 00:06:37,110
For this will create a
new client proxy class that

114
00:06:37,110 --> 00:06:38,580
internally updates the message
headers with the trace ID

115
00:06:38,820 --> 00:06:40,440
before publishing a message.

116
00:06:40,890 --> 00:06:41,250
So

117
00:06:41,520 --> 00:06:43,320
as generate a new module first

118
00:06:43,440 --> 00:06:45,701
called nats dash client.

119
00:06:46,110 --> 00:06:48,840
And let's make sure to
select the tracing library

120
00:06:48,990 --> 00:06:50,830
as the modules destination.

121
00:06:54,690 --> 00:06:55,170
Next

122
00:06:55,290 --> 00:06:56,490
inside of this module

123
00:06:56,610 --> 00:07:00,880
let's create a new file called
constance with the following content.

124
00:07:07,290 --> 00:07:12,010
This file simply exports a constant that
will represent the nats client provider.

125
00:07:12,900 --> 00:07:13,320
Next

126
00:07:13,500 --> 00:07:17,520
let's create yet another file and
call it nats dash client dot proxy

127
00:07:17,640 --> 00:07:19,210
with the following content.

128
00:07:21,210 --> 00:07:22,020
As we can see

129
00:07:22,260 --> 00:07:26,490
where injecting the client proxy instance
which represents our message broker

130
00:07:26,670 --> 00:07:29,681
and the context object
into the constructor.

131
00:07:30,750 --> 00:07:34,440
We'll use the client proxy to publish
messages to the message broker

132
00:07:34,680 --> 00:07:36,150
and the context object

133
00:07:36,300 --> 00:07:37,800
to access the trace ID

134
00:07:37,950 --> 00:07:40,270
that we attached to
the message earlier.

135
00:07:40,650 --> 00:07:41,280
Also

136
00:07:41,430 --> 00:07:43,140
been nats client proxy class

137
00:07:43,260 --> 00:07:44,850
marked as request scoped

138
00:07:45,060 --> 00:07:48,780
which means that a
new instance of this class

139
00:07:48,780 --> 00:07:49,780
will be created for
each incoming request.

140
00:07:50,100 --> 00:07:52,710
This is important current because
we want to make sure that each request

141
00:07:53,010 --> 00:07:56,380
has its own instance of
the nats client proxy class.

142
00:07:57,240 --> 00:07:59,160
Next up let's add a new method

143
00:07:59,280 --> 00:08:00,750
called set trace ID

144
00:08:01,050 --> 00:08:05,230
that will be responsible for updating
the message headers with the trace ID.

145
00:08:09,570 --> 00:08:12,840
Here we're checking if the message
is an instance of nats record or know.

146
00:08:13,350 --> 00:08:13,920
If it is.

147
00:08:14,250 --> 00:08:16,980
Recruiting a new instance of
the nats record build their class

148
00:08:17,280 --> 00:08:19,960
and updating its
headers with the trace ID.

149
00:08:20,340 --> 00:08:24,150
Otherwise we're creating a new instance
of the nats record build their class and

150
00:08:24,150 --> 00:08:27,160
updating its data and
headers with the to trace ID.

151
00:08:28,410 --> 00:08:28,920
Finally

152
00:08:29,100 --> 00:08:34,420
let's add a new methods called cent
and emit to mimic the client proxy a PR.

153
00:08:35,700 --> 00:08:36,810
Last but not least

154
00:08:36,930 --> 00:08:41,970
let's open up the nats
client module file and

155
00:08:41,970 --> 00:08:42,570
register this nats client
proxy as a provider

156
00:08:42,750 --> 00:08:44,350
and make sure to export.

157
00:08:45,780 --> 00:08:46,320
Also

158
00:08:46,590 --> 00:08:50,520
let's not forget to import the
client module here with the

159
00:08:50,520 --> 00:08:52,330
exact same configuration
we have in other applications.

160
00:09:01,770 --> 00:09:02,250
Great

161
00:09:02,610 --> 00:09:06,600
but this in place let's switch back to our
alarm service and update the alarm service

162
00:09:06,600 --> 00:09:10,001
module file to import
the nats client module.

163
00:09:10,230 --> 00:09:14,142
You can also remove the nats configuration
from the clients module array.

164
00:09:17,850 --> 00:09:18,900
Last but not least

165
00:09:19,170 --> 00:09:23,340
let's update the alarm service controller
file to inject the nats client proxy

166
00:09:23,520 --> 00:09:25,841
instead of just client proxy.

167
00:09:33,990 --> 00:09:35,610
Just before we
test everything out

168
00:09:35,910 --> 00:09:39,840
let's also update the alarms
classifier service to use the tracing lager

169
00:09:40,020 --> 00:09:42,030
instead of the
local lager instance

170
00:09:42,270 --> 00:09:42,690
so.

171
00:09:43,050 --> 00:09:46,110
As open up our alarms
classifier service module file

172
00:09:46,410 --> 00:09:49,060
and import the
tracing module there.

173
00:09:49,590 --> 00:09:50,010
Next

174
00:09:50,190 --> 00:09:52,980
let's open up the alarms
classifier service controller file

175
00:09:53,220 --> 00:09:55,410
and replaced the
local lager instance

176
00:09:55,530 --> 00:09:57,857
with our new tracing lager.

177
00:10:02,490 --> 00:10:04,060
Let's save our changes.

178
00:10:04,290 --> 00:10:07,150
Head over to the terminal
and take a look at those logs.

179
00:10:12,328 --> 00:10:17,007
As we can see the trace
ID is now propagated to

180
00:10:17,038 --> 00:10:18,038
the alarms class of our
services well fantastic.

181
00:10:18,748 --> 00:10:22,028
The last missing piece
is the notification service.

182
00:10:22,558 --> 00:10:26,488
However it uses rabbit
mq instead of nats so

183
00:10:26,608 --> 00:10:29,458
we would have to create a
new rabbit client proxy class

184
00:10:29,728 --> 00:10:30,778
that would be similar

185
00:10:30,928 --> 00:10:33,968
to the nats client proxy
class we just created.

186
00:10:34,318 --> 00:10:38,428
As this would be a lot of repetitive work
we won't be doing this in this course you

187
00:10:38,428 --> 00:10:39,958
can think of this is a
homework assignment

188
00:10:40,108 --> 00:10:42,818
if you want to practice
your skills and do it yourself.

189
00:10:42,958 --> 00:10:44,188
So to recap

190
00:10:44,488 --> 00:10:48,898
distributed tracing is a powerful tool that
enables developers and operator and teams

191
00:10:48,928 --> 00:10:52,778
to gain deep insights into
complex microservices architectures.

192
00:10:53,128 --> 00:10:57,508
We now have all the basic elements set
up ourselves that could be used in any real

193
00:10:57,508 --> 00:11:01,148
world nastiest microservice
application you work on in the future.

194
00:11:01,380 --> 00:11:04,268
Distributed tracing is so
beneficial microservices.

195
00:11:04,558 --> 00:11:06,268
As it promotes
better understanding

196
00:11:06,388 --> 00:11:07,558
smoother debugging

197
00:11:07,768 --> 00:11:09,968
a more efficient
performance optimization.

198
00:11:10,198 --> 00:11:13,018
Making get it an essential
part of building and maintaining

199
00:11:13,228 --> 00:11:15,878
resilient microservices
based systems.

200
00:11:16,648 --> 00:11:20,818
For production applications
consider using more

201
00:11:20,878 --> 00:11:22,318
sophisticated instrumentation
tools such as oh open telemetry

202
00:11:22,498 --> 00:11:23,818
in combination with jaeger

203
00:11:23,938 --> 00:11:26,168
for visualization and analysis.

204
00:11:26,998 --> 00:11:30,628
These tools provide a more comprehensive
solution for distributed tracing and can be

205
00:11:30,688 --> 00:11:33,218
easily integrated with
nastiest applications.

206
00:11:33,988 --> 00:11:35,368
And that's all for this course

207
00:11:35,488 --> 00:11:40,268
but thank you again for being here
supporting sjs and learning nest with us.

208
00:11:40,348 --> 00:11:42,148
We hope you learned
a lot with this course.

209
00:11:42,658 --> 00:11:44,998
Make sure to check out the
entire catalogue of courses

210
00:11:45,328 --> 00:11:47,608
to learn everything else
from advanced techniques

211
00:11:47,728 --> 00:11:49,239
to nest fundamentals.

212
00:11:49,318 --> 00:11:50,978
See you in the next one.

